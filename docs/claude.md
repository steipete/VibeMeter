## Technical Specification: Integrating Claude Usage Tracking into VibeMeter

### 1. Project Overview & High-Level Plan

The goal is to add support for tracking usage of Anthropic's Claude to the existing VibeMeter macOS application. Unlike the current Cursor integration, which uses API calls, the Claude provider will **read local log files** generated by Claude's official applications (e.g., the VS Code extension or desktop app).

This feature will be implemented without requiring a user login for Claude. Instead, users will select their account type (e.g., "Pro," "Free") in the settings, and the app will request one-time access to the Claude log directory.

**Key Features to Implement:**
1.  **Local Log Parsing:** Securely read and parse usage data from `~/.claude/projects/`.
2.  **No-Login Authentication:** A user selects their Claude subscription type in settings.
3.  **Dual-Mode Menu Bar Gauge:** The main gauge icon can be configured to show either total monthly spending (like Cursor) or the remaining 5-hour window quota for Claude Pro.
4.  **Popover UI Enhancements:** The popover will display today's approximate cost and a dedicated section for the 5-hour window usage.
5.  **Detailed Daily Breakdown:** A new settings view will display a day-by-day table of token usage and calculated costs, similar to the `ccusage` tool.
6.  **Accurate Tokenization:** Integrate a Swift implementation of the `tiktoken` library and update it with the `o200k_base` encoding for accurate estimations.

The implementation will be divided into four phases:
*   **Phase 1: Core Logic & Foundation:** Setting up the tokenizer, file access, and the log parser.
*   **Phase 2: Provider Integration:** Creating the Claude provider and integrating it into the app's multi-provider architecture.
*   **Phase 3: Settings UI:** Building the user-facing configuration screens.
*   **Phase 4: Menu Bar & Popover UI:** Implementing the main user interface features.

---

### Phase 1: Core Logic & Foundation

#### Step 1.1: Integrate the Tokenizer

We will copy the Swift `Tiktoken` library files directly into the project to have full control and to add the `o200k_base` encoding.

1.  **Create a New Group:** In Xcode, create a new group under `VibeMeter/Core/Utilities/` named `Tiktoken`.
2.  **Download and Add Files:**
    *   Go to the `aespinilla/Tiktoken` GitHub repository: `https://github.com/aespinilla/Tiktoken`
    *   Download the source files from the `Sources/Tiktoken/` directory.
    *   Add these Swift files to the new `Tiktoken` group in your Xcode project.
3.  **Add `o200k_base` Vocabulary:**
    *   Download the official vocabulary file from OpenAI: `https://openaipublic.blob.core.windows.net/encodings/o200k_base.tiktoken`
    *   Rename this file to `o200k_base.tiktoken` if it's not already named that.
    *   Add this file to the `Tiktoken` group in Xcode. **Crucially, ensure it is included in the "Copy Bundle Resources" build phase for your app target.**
4.  **Update `Encoding.swift`:**
    *   Open the `Encoding.swift` file (or equivalent enum file) within the `Tiktoken` group.
    *   Add the new case to the `Encoding` enum:
        ```swift
        public enum Encoding: String, CaseIterable {
            case r50k_base = "r50k_base"
            case p50k_base = "p50k_base"
            case cl100k_base = "cl100k_base"
            case o200k_base = "o200k_base" // Add this line
        }
        ```

#### Step 1.2: Create Claude-Specific Data Models

Create a new file at `VibeMeter/Core/Models/ClaudeUsageData.swift`. This will hold the structured data parsed from the logs.

```swift
// VibeMeter/Core/Models/ClaudeUsageData.swift
import Foundation

struct ClaudeLogEntry: Decodable, Identifiable {
    var id = UUID()
    let timestamp: Date
    let model: String?
    let inputTokens: Int
    let outputTokens: Int

    enum CodingKeys: String, CodingKey {
        case timestamp, model, message
    }

    enum MessageKeys: String, CodingKey {
        case usage
    }

    enum UsageKeys: String, CodingKey {
        case inputTokens = "input_tokens"
        case outputTokens = "output_tokens"
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        // Decode timestamp with robust date formatting
        let dateString = try container.decode(String.self, forKey: .timestamp)
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        if let date = formatter.date(from: dateString) {
            self.timestamp = date
        } else {
            throw DecodingError.dataCorruptedError(forKey: .timestamp, in: container, debugDescription: "Date string does not match expected format.")
        }
        
        let messageContainer = try container.nestedContainer(keyedBy: MessageKeys.self, forKey: .message)
        self.model = try container.decodeIfPresent(String.self, forKey: .model)
        
        let usageContainer = try messageContainer.nestedContainer(keyedBy: UsageKeys.self, forKey: .usage)
        self.inputTokens = try usageContainer.decode(Int.self, forKey: .inputTokens)
        self.outputTokens = try usageContainer.decode(Int.self, forKey: .outputTokens)
    }
}

// Represents the data needed for the 5-hour window
struct FiveHourWindow {
    let used: Double
    let total: Double
    let resetDate: Date
    
    var remaining: Double {
        total - used
    }
    
    var percentageUsed: Double {
        total > 0 ? (used / total) : 0
    }
}
```

#### Step 1.3: Implement the Log File Parser and Sandbox Access

This is the most critical part. We need a service that can ask for folder access, store that access securely, and then parse the files.

1.  **Create `ClaudeLogManager.swift`:** Create this new file at `VibeMeter/Core/Services/ClaudeLogManager.swift`.

    ```swift
    // VibeMeter/Core/Services/ClaudeLogManager.swift
    import Foundation
    import os.log
    import Tiktoken

    @MainActor
    class ClaudeLogManager {
        static let shared = ClaudeLogManager()
        private let logger = Logger(subsystem: "com.vibemeter", category: "ClaudeLogManager")
        private let fileManager = FileManager.default
        private let logDirectoryName = ".claude/projects"
        private var bookmarkData: Data?

        private lazy var tiktoken: Tiktoken? = {
            try? Tiktoken(encoding: .o200k_base)
        }()

        private init() {
            loadBookmark()
        }

        func requestLogAccess() async -> Bool {
            let openPanel = NSOpenPanel()
            openPanel.message = "Please select your home directory to grant VibeMeter access to the ~/.claude folder."
            openPanel.prompt = "Grant Access"
            openPanel.canChooseFiles = false
            openPanel.canChooseDirectories = true
            openPanel.canCreateDirectories = false
            openPanel.directoryURL = fileManager.homeDirectoryForCurrentUser

            let response = await openPanel.begin()
            guard response == .OK, let url = openPanel.url else { return false }
            
            do {
                let bookmark = try url.bookmarkData(options: .withSecurityScope, includingResourceValuesForKeys: nil, relativeTo: nil)
                saveBookmark(data: bookmark)
                logger.info("Successfully created security-scoped bookmark for folder access.")
                return true
            } catch {
                logger.error("Failed to create bookmark: \(error.localizedDescription)")
                return false
            }
        }
        
        func hasAccess() -> Bool {
            return bookmarkData != nil
        }
        
        func getDailyUsage() async -> [Date: [ClaudeLogEntry]] {
            guard let accessURL = resolveBookmark() else { return [:] }
            defer { accessURL.stopAccessingSecurityScopedResource() }

            let claudeURL = accessURL.appendingPathComponent(logDirectoryName)
            var dailyUsage: [Date: [ClaudeLogEntry]] = [:]

            guard let enumerator = fileManager.enumerator(at: claudeURL, includingPropertiesForKeys: [.isRegularFileKey], options: [.skipsHiddenFiles, .skipsPackageDescendants]) else {
                return [:]
            }

            for case let fileURL as URL in enumerator {
                guard fileURL.pathExtension == "jsonl" else { continue }
                
                do {
                    let content = try String(contentsOf: fileURL)
                    let lines = content.split(separator: "\n")
                    let decoder = JSONDecoder()
                    
                    for line in lines {
                        guard let data = String(line).data(using: .utf8) else { continue }
                        if let entry = try? decoder.decode(ClaudeLogEntry.self, from: data) {
                            let day = Calendar.current.startOfDay(for: entry.timestamp)
                            dailyUsage[day, default: []].append(entry)
                        }
                    }
                } catch {
                    logger.error("Failed to read or parse file \(fileURL.lastPathComponent): \(error.localizedDescription)")
                }
            }
            return dailyUsage
        }

        private func saveBookmark(data: Data) {
            do {
                try data.write(to: bookmarkFileURL())
                self.bookmarkData = data
            } catch {
                logger.error("Failed to save bookmark data: \(error.localizedDescription)")
            }
        }
        
        private func loadBookmark() {
            guard let data = try? Data(contentsOf: bookmarkFileURL()) else { return }
            self.bookmarkData = data
        }

        private func resolveBookmark() -> URL? {
            guard let bookmarkData else { return nil }
            do {
                var isStale = false
                let url = try URL(resolvingBookmarkData: bookmarkData, options: .withSecurityScope, relativeTo: nil, bookmarkDataIsStale: &isStale)
                if isStale {
                    logger.warning("Bookmark is stale, attempting to refresh.")
                    let newBookmark = try url.bookmarkData(options: .withSecurityScope, includingResourceValuesForKeys: nil, relativeTo: nil)
                    saveBookmark(data: newBookmark)
                }
                guard url.startAccessingSecurityScopedResource() else {
                    logger.error("Failed to start accessing security-scoped resource.")
                    return nil
                }
                return url
            } catch {
                logger.error("Failed to resolve bookmark: \(error.localizedDescription)")
                self.bookmarkData = nil // Invalidate bookmark if it fails
                return nil
            }
        }

        private func bookmarkFileURL() -> URL {
            let applicationSupport = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
            return applicationSupport.appendingPathComponent("VibeMeter/claude_folder_bookmark.data")
        }
    }
    ```

2.  **Add Sandboxing Entitlement:** Open `VibeMeter/VibeMeter.entitlements` and add the following key to allow bookmark storage and resolution.
    ```xml
    <key>com.apple.security.files.bookmarks.app-scope</key>
    <true/>
    ```

---

### Phase 2: Provider Integration

#### Step 2.1: Add Claude to `ServiceProvider.swift`

Modify `VibeMeter/Core/Providers/ServiceProvider.swift` to include `.claude`.

```swift
// VibeMeter/Core/Providers/ServiceProvider.swift
public enum ServiceProvider: String, CaseIterable, Codable, Sendable {
    case cursor
    case claude // Add this case

    public var displayName: String {
        switch self {
        case .cursor: "Cursor"
        case .claude: "Claude" // Add this
        }
    }
    
    // ... update all other switch statements in this file to include a case for .claude
    // For many, you can use a default or return an appropriate value.
    // For example, `supportsTeams` for Claude would be `false`.
    // The `keychainService` should be unique, e.g., "com.vibemeter.claude".
}
```

#### Step 2.2: Create the `ClaudeProvider.swift`

This is the central piece connecting the log parser to the app's architecture. It will conform to `ProviderProtocol` but will mostly use local data instead of network calls.

Create a new file at `VibeMeter/Core/Providers/ClaudeProvider.swift`.

```swift
// VibeMeter/Core/Providers/ClaudeProvider.swift
import Foundation
import os.log

public actor ClaudeProvider: ProviderProtocol {
    public let provider: ServiceProvider = .claude
    private let logger = Logger(subsystem: "com.vibemeter", category: "ClaudeProvider")
    private let logManager = ClaudeLogManager.shared

    // This provider doesn't use tokens/network in the same way.
    // We will return dummy or non-applicable values for most protocol requirements.

    public func fetchTeamInfo(authToken: String) async throws -> ProviderTeamInfo {
        // Not applicable for our Claude implementation
        throw ProviderError.unsupportedProvider(.claude)
    }

    public func fetchUserInfo(authToken: String) async throws -> ProviderUserInfo {
        // We can derive a "user" from the home directory path
        let homeDir = FileManager.default.homeDirectoryForCurrentUser.lastPathComponent
        return ProviderUserInfo(email: "\(homeDir) (Local)", provider: .claude)
    }
    
    public func fetchMonthlyInvoice(authToken: String, month: Int, year: Int, teamId: Int?) async throws -> ProviderMonthlyInvoice {
        // This is the core data fetching method.
        // We will adapt it to return data from our log parser.
        let dailyUsage = await logManager.getDailyUsage()
        
        let calendar = Calendar.current
        let components = DateComponents(year: year, month: month + 1) // month is 0-indexed
        guard let dateInMonth = calendar.date(from: components) else {
            throw ProviderError.decodingError(message: "Invalid month/year", statusCode: nil)
        }

        let items = dailyUsage.flatMap { $0.value }
            .filter { calendar.isDate($0.timestamp, equalTo: dateInMonth, toGranularity: .month) }
            .map { entry in
                let costCents = Int(calculateCost(input: entry.inputTokens, output: entry.outputTokens) * 100)
                return ProviderInvoiceItem(cents: costCents, description: "Claude Usage", provider: .claude)
            }
        
        return ProviderMonthlyInvoice(items: items, provider: .claude, month: month, year: year)
    }

    public func fetchUsageData(authToken: String) async throws -> ProviderUsageData {
        // We can adapt this to return the 5-hour window data.
        // For this example, we'll return a simplified version. The orchestrator will handle the real logic.
        return ProviderUsageData(
            currentRequests: 0, totalRequests: 0, maxRequests: 100, // Placeholder
            startOfMonth: Date(), provider: .claude)
    }

    public func validateToken(authToken: String) async -> Bool {
        // We use file access as our "validation"
        return await logManager.hasAccess()
    }
    
    public nonisolated func getAuthenticationURL() -> URL {
        // Not used, but required by protocol.
        return URL(string: "file://localhost")!
    }
    
    public nonisolated func extractAuthToken(from callbackData: [String: Any]) -> String? {
        // Not used. Return a dummy token to satisfy the login flow.
        return "local_claude_token"
    }
    
    // Helper for cost calculation
    private func calculateCost(input: Int, output: Int) -> Double {
        // Use pricing from research (this should be moved to a config)
        let inputCostPerMillion = 3.0
        let outputCostPerMillion = 15.0
        
        let cost = (Double(input) / 1_000_000 * inputCostPerMillion) + (Double(output) / 1_000_000 * outputCostPerMillion)
        return cost
    }
}
```

#### Step 2.3: Integrate into `ProviderFactory`

Modify `VibeMeter/Core/Providers/ProviderFactory.swift`.

```swift
// In createProvider(for:) function
public func createProvider(for provider: ServiceProvider) -> ProviderProtocol {
    switch provider {
    case .cursor:
        return CursorProvider(
            settingsManager: settingsManager,
            urlSession: urlSession)
    case .claude: // Add this case
        return ClaudeProvider()
    }
}
```

---

### Phase 3: Settings UI Implementation

#### Step 3.1: Add New Settings to `DisplaySettingsManager`

Modify `VibeMeter/Core/Services/Settings/DisplaySettingsManager.swift` to add a setting for the gauge.

```swift
// Add to Keys enum
private enum Keys {
    // ... existing keys
    static let gaugeRepresents = "gaugeRepresents"
}

// Add new property
public enum GaugeRepresentation: String, CaseIterable, Identifiable, Sendable {
    case totalSpending
    case claudeQuota
    
    public var id: String { rawValue }
    
    public var displayName: String {
        switch self {
        case .totalSpending: "Total Monthly Spending"
        case .claudeQuota: "Claude 5-Hour Quota"
        }
    }
}

public var gaugeRepresentation: GaugeRepresentation {
    didSet {
        userDefaults.set(gaugeRepresentation.rawValue, forKey: Keys.gaugeRepresents)
        logger.debug("Gauge representation set to: \(self.gaugeRepresentation.displayName)")
    }
}

// In init()
let savedGaugeRep = userDefaults.string(forKey: Keys.gaugeRepresents) ?? GaugeRepresentation.totalSpending.rawValue
gaugeRepresentation = GaugeRepresentation(rawValue: savedGaugeRep) ?? .totalSpending
```

#### Step 3.2: Add Account Type to `SessionSettingsManager`

We need a way to store the user's Claude subscription type since there's no login.

Modify `VibeMeter/Core/Services/Settings/SessionSettingsManager.swift`.

```swift
// Add to Keys enum
private enum Keys {
    // ... existing keys
    static let claudeAccountType = "claudeAccountType"
}

// Add new property
public enum ClaudeAccountType: String, CaseIterable, Codable, Sendable {
    case free = "Free"
    case pro = "Pro"
    
    public var id: String { rawValue }
}

public var claudeAccountType: ClaudeAccountType {
    didSet {
        userDefaults.set(claudeAccountType.rawValue, forKey: Keys.claudeAccountType)
        logger.debug("Claude account type set to: \(self.claudeAccountType.rawValue)")
    }
}

// In init()
let savedAccountType = userDefaults.string(forKey: Keys.claudeAccountType) ?? ClaudeAccountType.pro.rawValue
claudeAccountType = ClaudeAccountType(rawValue: savedAccountType) ?? .pro
```

#### Step 3.3: Create `ClaudeDetailView.swift`

This view will show the daily usage breakdown. Create it at `VibeMeter/Presentation/Views/ClaudeDetailView.swift`.

```swift
// VibeMeter/Presentation/Views/ClaudeDetailView.swift
import SwiftUI

struct ClaudeDetailView: View {
    @State private var dailyUsage: [Date: [ClaudeLogEntry]] = [:]
    
    var body: some View {
        VStack {
            Text("Claude Daily Usage").font(.title)
            // Use a List or Table to display the `dailyUsage` data
            // This is a simplified example; you'd use a proper Table for macOS
            List {
                ForEach(dailyUsage.keys.sorted(by: >), id: \.self) { day in
                    Section(header: Text(day, style: .date)) {
                        let totalInput = dailyUsage[day]?.reduce(0) { $0 + $1.inputTokens } ?? 0
                        let totalOutput = dailyUsage[day]?.reduce(0) { $0 + $1.outputTokens } ?? 0
                        Text("Input: \(totalInput.formatted()) tokens")
                        Text("Output: \(totalOutput.formatted()) tokens")
                    }
                }
            }
        }
        .task {
            dailyUsage = await ClaudeLogManager.shared.getDailyUsage()
        }
    }
}
```

#### Step 3.4: Update `ProvidersSettingsView`

Modify `VibeMeter/Presentation/Views/ProvidersSettingsView.swift` to handle the new Claude provider, which has different logic (no login button, but a "Grant Access" button if needed). You'll need to create a custom `ClaudeProviderRowView`.

---

### Phase 4: Menu Bar & Popover UI

#### Step 4.1: Update `StatusBarController`

The logic in `updateStatusItemState` needs to be updated to handle the new gauge representation setting.

Modify `VibeMeter/Presentation/Components/StatusBarController.swift`.

```swift
// Inside updateStatusItemState()
private func updateStatusItemState() {
    // ... existing logic to get isLoggedIn, isFetchingData, etc.

    if settingsManager.gaugeRepresentation == .claudeQuota && userSessionData.isLoggedIn(to: .claude) {
        // New logic to calculate Claude 5-hour window usage
        // This will be complex and should be handled by a dedicated method
        // For now, let's assume we get a value from a new service.
        let claudeQuotaValue = calculateClaudeQuota() // This function needs to be implemented
        stateManager.setState(.data(value: claudeQuotaValue))
    } else {
        // Original logic for total spending
        let totalSpendingUSD = // ...
        let gaugeValue = // ...
        stateManager.setState(.data(value: gaugeValue))
    }
}
```

#### Step 4.2: Update the Main Popover View

Modify `VibeMeter/Presentation/Views/LoggedInContentView.swift` to include the new section for Claude's 5-hour window.

```swift
// Inside LoggedInContentView's body
struct LoggedInContentView: View {
    // ...
    
    var body: some View {
        VStack(spacing: 0) {
            // ... UserHeaderView and Divider
            
            VStack(spacing: 6) {
                // Existing CostTableView
                CostTableView(...)

                // NEW: Add a dedicated view for Claude's quota if it's active
                if userSessionData.isLoggedIn(to: .claude) {
                    Divider().padding(.vertical, 4)
                    ClaudeQuotaView() // A new view you will create
                }
            }
            .padding(...)
            
            // ... Rest of the view (Last updated, Action buttons)
        }
    }
}
```

Create `ClaudeQuotaView.swift` in `VibeMeter/Presentation/Views/`. This view will display the progress bar and text for the 5-hour window. It will need to get its data from a service that calculates this based on the parsed logs.

---

### Final Integration & Data Flow Summary

1.  **On App Launch:** The `AppDelegate` initializes the `MultiProviderDataOrchestrator`.
2.  **Claude Provider:** The `ProviderFactory` will now be able to create a `ClaudeProvider`. The orchestrator will manage it alongside Cursor.
3.  **Data Fetching:** When `refreshData(for: .claude)` is called, the `ClaudeProvider` will use the `ClaudeLogManager` to parse the files.
    *   If `ClaudeLogManager` doesn't have access, it will trigger the UI to show a "Grant Access" button.
4.  **Data Processing:** The log entries are processed to calculate daily usage and the current 5-hour window usage. This data flows into the `MultiProviderSpendingData` observable model.
5.  **UI Updates:**
    *   The `LoggedInContentView` will now have access to both Cursor and Claude data.
    *   It will conditionally display the `ClaudeQuotaView`.
    *   The `StatusBarController` will read `settingsManager.gaugeRepresentation` and update the `MenuBarStateManager` with either the spending percentage or the Claude quota percentage, which in turn updates the `GaugeIcon`.
    *   The settings screens will allow the user to select their Claude account type and configure the menu bar gauge.